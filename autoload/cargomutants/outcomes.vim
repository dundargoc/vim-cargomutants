let s:saved_cpo = &cpoptions
set cpoptions&vim


function! cargomutants#outcomes#GetLogFilePath(key) abort
  if !exists('b:cargomutants_outcomes')
    let b:cargomutants_outcomes = cargomutants#outcomes#BuildOutcomesData()
  endif

  if has_key(b:cargomutants_outcomes, a:key)
    " TODO: check key `log_path` exists
    let l:f = b:cargomutants_outcomes[a:key].log_path
    if l:f[0] ==# '/'
      return l:f
    else
      return resolve(join([b:cargomutants_root_dir, l:f], '/'))
    endif
  endif

  return v:null
endfunction


function! cargomutants#outcomes#BuildOutcomesData() abort
  let b:cargomutants_root_dir = cargomutants#utils#find_proj_root_dir()
  let l:json_file = join([b:cargomutants_root_dir, 'mutants.out', 'outcomes.json'], '/')
  if !filereadable(l:json_file)
    " No cargo-mutants outcomes.json found
    return
  endif
  let l:json = json_decode(join(readfile(l:json_file), ''))

  let l:mutants = {}
  for l:e in l:json.outcomes
    if type(l:e.scenario) != v:t_dict | continue | endif
    if !has_key(l:e.scenario, 'Mutant') | continue | endif
    let l:mut = l:e.scenario.Mutant
    let l:text = cargomutants#outcomes#BuildLocListText(l:e.summary, l:mut.function, l:mut.return_type, l:mut.replacement)
    let l:mut_key = cargomutants#outcomes#BuildOutcomeKey(l:mut.file, l:mut.line, l:text)

    let l:mutants[l:mut_key] = l:e

  endfor
  return l:mutants
endfunction


function! cargomutants#outcomes#build_uncaught_mutants_list(outcomes_json) abort
  let l:mutants = []
  for l:e in a:outcomes_json.outcomes
    if type(l:e.scenario) != v:t_dict | continue | endif
    if !has_key(l:e.scenario, 'Mutant') | continue | endif
    let l:err_type = s:get_mutant_result_type(l:e)
    if l:err_type ==# v:null | continue | endif
    let l:mut = l:e.scenario.Mutant
    let l:mutants += [{
          \ 'filename': b:cargomutants_root_dir . '/'. l:mut.file,
          \ 'lnum': l:mut.line,
          \ 'type': l:err_type,
          \ 'text': cargomutants#outcomes#BuildLocListText(
          \           l:e.summary,
          \           l:mut.function, l:mut.return_type,
          \           l:mut.replacement),
          \ }]
  endfor
  return l:mutants
endfunction


" returns v:null if mutant is caught, otherwise return error type:
"   'e' if error, 'w' if warning
function! s:get_mutant_result_type(outcome) abort
  for l:result in a:outcome.phase_results
    if l:result.phase ==# 'Test' && l:result.cargo_result ==# 'Success'
      return 'e'
    endif
    if l:result.phase ==# 'Build' && l:result.cargo_result ==# 'Failure'
      return 'w'
    endif
  endfor
  return v:null
endfunction


function! cargomutants#outcomes#BuildOutcomeKey(file, line, text) abort
  let l:text = a:text
  " because ALE alows customizing message format with `g:ale_echo_msg_format`
  " it's difficult to extract the part of text generated by cargomutants
  " the following is only a hack for my own message format as: '[%linter%] %s'
  let l:text = substitute(l:text, '\s*\[cargomutants\]\s*', '', '')
  let l:key = join([a:file, a:line, l:text], '-')
  return l:key
endfunction


" not only for text in list item, but also part of lookup key
function! cargomutants#outcomes#BuildLocListText(
      \ summary, function, return_type, replacement) abort
  let l:s = printf('[%s] %s%s replaced with %s',
        \   a:summary, a:function,
        \   a:return_type !=# '' ? ' ' . a:return_type : '',
        \   a:replacement)
  return l:s
endfunction


function! cargomutants#outcomes#get_stats()abort
  let b:cargomutants_root_dir = cargomutants#utils#find_proj_root_dir()
  let l:json_file = join([b:cargomutants_root_dir, 'mutants.out', 'outcomes.json'], '/')
  if !filereadable(l:json_file)
    " No cargo-mutants outcomes.json found
    return
  endif
  let l:json = json_decode(join(readfile(l:json_file), ''))
  let l:stats = {
        \ 'total': l:json.total_mutants,
        \ 'missed': l:json.missed,
        \ 'caught': l:json.caught,
        \ 'timeout': l:json.timeout,
        \ 'unviable': l:json.unviable,
        \ 'success': l:json.success,
        \ 'failure': l:json.failure,
        \}
  return l:stats
endfunction


let &cpoptions = s:saved_cpo
unlet s:saved_cpo
